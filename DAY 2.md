# DAY 2

## Fermat

看到这个标题，我边想着是不是用fermat素性检验，emmm，打开题目一康，只给了n和c，稍加思索后我觉得这可能是想让我分解n了，但是如果直接暴力分解显然是不行滴QAQ，接着转念一想，这可能是想让我随机roll个$2<x<n$,然后让我用Fermat素性检验判断是不是素数，于是接下来就是一点小小说明Fermat素性检验时间:

### 费马素性检验

由费马小定理可以知道，如果p是一个素数，而$gcd(a,p)==1$，则有$a^{p-1}≡1（\mod p）$ 

那么我们就可以假设上述roll到的x为素数，则不妨再roll一个数a使得gcd(a,x)==1且a不为*偶数*并判断a是否满足$a^{x-1}≡1（\mod x）$,若不满足，则x一定不为素数，但若满足我们不能确定x就一定是素数，只能说x很有可能是素数，因为有Carmichael数的存在QAQ（Carmichael数是指如果一个数x可以通过所有a的费马素性检验却并非为素数，那么就叫n为Carmichael数。不过这样的数随着n的增大而越来越少的），而且有些合数也可能满足条件呀，但是只要我检验的次数足够多，除了万恶的Carmichael数,还是可以将x为素数的可能性提到非常高的！（其实我就是在碰运气QAQ）

### 回归题目

但是但是，又一个小小的细节出现了！！！如果直接roll个x的话，我这明显就是在碰运气呀！！！接着，我非常amazing地发现了q=next_prime(p).好耶!这不就意味着p,q实际上十分接近了吗？于是一个大胆的想法出现了：如果我直接从isqrt(n)向后开始枚举素数的话，是不是可以大大降低时间了呢？于是怀着试试看的想法，尝试了如下代码,然后flag如愿来到了我身边ouo

```python
from gmpy2 import *
from Crypto.Util.number import *
import random
def Femat(n):
    t=(math.isqrt(n))-1
    while True:
        flag=1
        t=t+1
        if t % 2 == 0:
            continue
        for i in range(0,30):
            while True:
                a=random.randint(2,t-1)
                if t % a :
                    break
            if powmod(a,t-1,t)!=1:
                flag=0
        if flag ==0 or n % t:
            continue
        else :
            return t

n=28616436294339246031635440020440605953297444145645106292605070210891504021289157258299537050250133649462876165035923364845638064139218170920426653914730275944576947882837909144289021696675819165790093486445015091867766612934908426814128674987887151179393518824187877995956873860391907789780265155534337637592727295426730417238630276726686482774076678284139416432327274326873521600906127291504477243122098543410749068286738776469061991037925437919153816018169235553188084279471690554390626341778677003795380435178227573229978051606761130658271041246726251444598535744060058353588363542098444706348233534598740692440179
p=Femat(n)
q=n//p
print(p*q==n)
print(p)
print(q)
c=23332102242134854265358763314083789449958733092899235804586893685135993705527111978439696964168810176034645028617982837844222523005693883580874530755937829134627675783804179162613532694190620077163539626396734194336042945814945459571022176110636043239848489890081467095837333901801526005453143198751448161393506750052993802621883212988360243499119613048248520704126102697522385754391309383330228576139844699636423221613252919005812725743676246244431245582679367979172594304622446426398742443701589201209252046759860097394191842653518483189691319971748938078193375630663853157772771243737345895826674932068901538580026
e=65537
phi=(p - 1) * (q - 1)
d=invert(e,phi)
m=powmod(c,d,n)
print(long_to_bytes(m))

```

### The End  

小小吐槽：github感觉还是好难用QAQ